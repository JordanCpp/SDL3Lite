/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef SDL3Lite_Vector_hpp
#define SDL3Lite_Vector_hpp

#include <assert.h>
#include <SDL3/New.hpp>

template <typename T>
class Vector
{
public:
	// Type definitions for C++98 compatibility
	typedef T value_type;
	typedef size_t size_type;
	typedef T* iterator;
	typedef const T* const_iterator;

private:
	size_t _capacity;
	size_t _position;
	T*     _content;

	T* allocate(size_t count)
	{
		if (count == 0)
			return NULL;
		return new T[count];
	}

	void deallocate(T* ptr)
	{
		if (ptr != NULL)
		{
			delete[] ptr;  // ✅ ИСПРАВЛЕНО: используем переданный указатель
		}
	}

	void destroy_elements()
	{
		// Вызываем деструкторы для элементов (важно для non-POD типов)
		for (size_t i = 0; i < _position; i++)
		{
			_content[i].~T();
		}
	}

public:
	// Default constructor
	Vector() :
		_capacity(0),
		_position(0),
		_content(NULL)
	{
	}

	// Copy constructor (Rule of Three)
	Vector(const Vector& other) :
		_capacity(0),
		_position(0),
		_content(NULL)
	{
		if (other._position > 0)
		{
			reserve(other._capacity);
			_position = other._position;
			for (size_t i = 0; i < _position; i++)
			{
				_content[i] = other._content[i];
			}
		}
	}

	// Assignment operator (Rule of Three)
	Vector& operator=(const Vector& other)
	{
		if (this != &other)
		{
			// Очищаем текущее содержимое
			clear();
			if (_content != NULL)
			{
				deallocate(_content);
				_content = NULL;
				_capacity = 0;
			}
			
			// Копируем данные
			if (other._position > 0)
			{
				reserve(other._capacity);
				_position = other._position;
				for (size_t i = 0; i < _position; i++)
				{
					_content[i] = other._content[i];
				}
			}
		}
		return *this;
	}

	// Destructor (Rule of Three)
	~Vector()
	{
		if (_content != NULL)
		{
			destroy_elements();
			deallocate(_content);
		}
	}

	// Capacity methods
	size_t capacity() const
	{
		return _capacity;
	}

	size_t size() const
	{
		return _position;
	}

	bool empty() const
	{
		return _position == 0;
	}

	// Data access
	const T* data() const
	{
		return _content;
	}

	T* data()
	{
		return _content;
	}

	// Memory management
	void reserve(size_t count)
	{
		if (count == 0 || count <= _capacity)
			return;

		T* p = allocate(count);
		if (p == NULL)  // Проверка на неудачное выделение памяти
			return;

		// Копируем существующие элементы
		for (size_t i = 0; i < _position; i++)
		{
			p[i] = _content[i];
		}

		// Освобождаем старую память
		if (_content != NULL)
		{
			destroy_elements();
			deallocate(_content);
		}

		_content = p;
		_capacity = count;
	}

	void resize(size_t count)
	{
		if (count > _capacity)
		{
			reserve(count);
		}

		// Если уменьшаем размер, вызываем деструкторы
		if (count < _position)
		{
			for (size_t i = count; i < _position; i++)
			{
				_content[i].~T();
			}
		}
		// Если увеличиваем, инициализируем новые элементы
		else if (count > _position && _content != NULL)
		{
			for (size_t i = _position; i < count; i++)
			{
				new (&_content[i]) T();  // Placement new для инициализации
			}
		}

		_position = count;
	}

	void clear()
	{
		destroy_elements();
		_position = 0;
	}

	// Element access
	void push_back(const T& element)
	{
		if (_capacity == 0)
		{
			reserve(2);
		}
		else if (_position >= _capacity)  // ✅ ИСПРАВЛЕНО: убрана лишняя проверка
		{
			reserve(_capacity * 2);
		}

		if (_content != NULL)  // Проверка на успешное выделение памяти
		{
			_content[_position] = element;
			_position++;
		}
	}

	void pop_back()
	{
		if (_position > 0)
		{
			_position--;
			_content[_position].~T();  // Вызов деструктора
		}
	}

	// Bounds-checked access
	const T& at(size_t index) const
	{
		assert(index < _position);  // ✅ ИСПРАВЛЕНО: правильная проверка границ
		return _content[index];
	}

	T& at(size_t index)
	{
		assert(index < _position);  // ✅ ИСПРАВЛЕНО: правильная проверка границ
		return _content[index];
	}

	// Unchecked access (faster)
	const T& operator[] (size_t index) const
	{
		assert(index < _position);  // ✅ ИСПРАВЛЕНО: правильная проверка границ
		return _content[index];
	}

	T& operator[] (size_t index)
	{
		assert(index < _position);  // ✅ ИСПРАВЛЕНО: правильная проверка границ
		return _content[index];
	}

	// Back element access
	const T& back() const
	{
		assert(_position > 0);
		return _content[_position - 1];
	}

	T& back()
	{
		assert(_position > 0);
		return _content[_position - 1];
	}

	const T& front() const
	{
		assert(_position > 0);
		return _content[0];
	}

	T& front()
	{
		assert(_position > 0);
		return _content[0];
	}

	// Iterator support (basic)
	iterator begin()
	{
		return _content;
	}

	const_iterator begin() const
	{
		return _content;
	}

	iterator end()
	{
		return _content + _position;
	}

	const_iterator end() const
	{
		return _content + _position;
	}

	// Utility methods
	void swap(Vector& other)
	{
		// Простой swap без использования std::swap
		T* temp_content = _content;
		size_t temp_capacity = _capacity;
		size_t temp_position = _position;

		_content = other._content;
		_capacity = other._capacity;
		_position = other._position;

		other._content = temp_content;
		other._capacity = temp_capacity;
		other._position = temp_position;
	}
};

#endif
